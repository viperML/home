[{"categories":["Linux"],"contents":"In this post, I want to show you how Nix can be used in a development environment to build this simple webpage.\nHugo Hugo is a static site generator written in Go. From a users\u0026rsquo;s perspective, you can simply select a template and a written text with no formatting, and it will generate all the files required for the website, including all the HTML, CSS styles, JS scripts. These written input is in form of Markdown, which is uses simple syntax to format the text, and can be edited with any text editor.\n# This is a title in Markdown! ## and a subtitle...  Lorem ipsum dolor sit amet, consectetur adipiscing elit. Mauris non consectetur massa, quis egestas est. - This - is - a list ```bash echo -e \u0026#34;And this is a codes snippet\\n\u0026#34; ``` Hugo templates can be easily found with a quick search in Google, and usually have a specific proyect layout (where to put and format your Markdown files), and require to have the theme repo cloned in the project folder.\nOnce your project is ready, building the site is as simple as:\nhugo # Or to get a live reloading preview in your browser: hugo server This will generate all the files required for the website, rendering out the details for the non web developer like me.\nNix Enter the Nix questions. Which version of hugo was used to build the site? What any other dependencies, like the theme, how much do we need from the user environment? Can we fully recreate the static website from another computer?\nIf properly configured, Nix can solve these problems, by using the (experimental) feature called flakes.\nOn a high level, the flake will provide an interface for our:\n Inputs: our source files, the template and the package dependencies (hugo) Output: the static files generated  The basic boilerplate for a flake can be as follows:\n{ inputs = { nixpkgs.url = github:NixOS/nixpkgs/nixos-unstable; flake-utils-plus.url = github:gytis-ivaskevicius/flake-utils-plus; }; outputs = inputs@{ self, nixpkgs, flake-utils-plus, ... }: flake-utils-plus.lib.mkFlake { inherit self inputs; outputsBuilder = (channels: { # Our outputs start here # my-awesome-output = foo; }); }; } The flake syntax define an attribute set { inputs = { ... }, outputs = { ... } }, for which the nix command will recognize the name of the attributes. For example, in inputs, we define \u0026lt;my input name\u0026gt;.url =  to declare any number of inputs. Outputs is a functions, which defines how our outputs must be built, given the inputs that are passed in the arguments. The flake-utils-plus library is an amazing piece of software that allows some abstraction and reuse of flake operations. For example, outputs are split into different systems, such as x86_64-linux or aarch64-linux (which are not the same because they use differently packages), so we would have to specify for each architecture. outputsBuilder automates this process for us.\nFinally, we can put our hugo blog as a output:\n{ inputs = { nixpkgs.url = github:NixOS/nixpkgs/nixos-unstable; flake-utils-plus.url = github:gytis-ivaskevicius/flake-utils-plus; bookworm = { url = github:gethugothemes/bookworm-light; flake = false; }; }; outputs = inputs @ { self, nixpkgs, flake-utils-plus, ... }: flake-utils-plus.lib.mkFlake { inherit self inputs; outputsBuilder = (channels: let pkgs = channels.nixpkgs; in { blog = pkgs.stdenv.mkDerivation { name = \u0026#34;blog\u0026#34;; src = ./.; buildPhase = \u0026#39;\u0026#39; mkdir -p themes ln -s ${inputs.bookworm}themes/bookworm ${pkgs.hugo}/bin/hugo --minify \u0026#39;\u0026#39;; installPhase = \u0026#39;\u0026#39; cp -r public $out \u0026#39;\u0026#39;; meta = with pkgs.lib; { description = \u0026#34;My awesome webpage\u0026#34;; license = licenses.cc-by-nc-sa-40; platforms = platforms.all; }; }; }); }; } Our blog output will be a derivation. You can think of a derivation as a folder which holds any stuff, and built with Nix. In this context, blog will be a derivation sitting in /nix/store/\u0026lt;hash\u0026gt;-blog, and it will contain our static website. To build it, we pass some basic information, such as name, src or meta, and then define the build and install phases. These are just bash snippets, which run in a sandboxed environment (no packages, no internet, etc). The rest is specfic to this project: we have to bring the template that we defined in our inputs. The ${ } syntax can be used to reference a derivation (a folder!), so calling ${inputs.bookworm} will just return the path to the theme folder. In the same way ${pkgs.hugo} is the folder in which the hugo binary is installed, so we just have to add the relative path to the binary.\nSo when we call nix build \u0026lt;the path to the project\u0026gt;#blog, what Nix will do is read the flake.lock file, pull the exact dependencies, and build the derivation. As the derivations ( ${pkgs. ...} ), are always subsituted for the same value, given the same lockfile, we are guaranteed to have the same output out of this flake, without taking into account any user environment, linux version, date, etc.\nIf you don\u0026rsquo;t believe this, you can checkout this blog\u0026rsquo;s repository and go to my last commit before writing this post. If all the sources are still available, you will get a exact copy of the website at this time:\ngit clone https://github.com/viperML/home \u0026amp;\u0026amp; cd home git checkout 416172a7da5129347fa95c166120a34252cc7815 nix build .#home.x86_64-linux ls result # or to get a live-reloading local server nix run .#serve GitHub pages To finish it up, we can deploy our website for free using GitHub pages, for which we just have to provide our static files, and github servers will do the rest, automatically. We don\u0026rsquo;t even have to manually build the website, as we can also keep it in the github ecosystem with GitHub Actions, a integration tool that will build the website for us. As we saw previously, if we use nix to build the website, the output will be the same, be it on our PC or in the cloud.\n","date":"05 Jan, 2022","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003cpicture\u003e\n  \u003csource srcset=\"/images/post/daniele-buso-qzUenL35ZYw-unsplash_hueee4619a26c2b0ecdcb5ccab13f7095e_1959320_545x0_resize_q95_h2_box.webp\" media=\"(max-width: 575px)\"\u003e\n  \u003csource srcset=\"/images/post/daniele-buso-qzUenL35ZYw-unsplash_hueee4619a26c2b0ecdcb5ccab13f7095e_1959320_600x0_resize_q95_h2_box.webp\" media=\"(max-width: 767px)\"\u003e\n  \u003csource srcset=\"/images/post/daniele-buso-qzUenL35ZYw-unsplash_hueee4619a26c2b0ecdcb5ccab13f7095e_1959320_700x0_resize_q95_h2_box.webp\" media=\"(max-width: 991px)\"\u003e\n  \u003csource srcset=\"/images/post/daniele-buso-qzUenL35ZYw-unsplash_hueee4619a26c2b0ecdcb5ccab13f7095e_1959320_1110x0_resize_q95_h2_box.webp\"\u003e\n  \u003cimg loading=\"lazy\" decoding=\"async\" class=\"w-100 img-fluid rounded\" src=\"/images/post/daniele-buso-qzUenL35ZYw-unsplash_hueee4619a26c2b0ecdcb5ccab13f7095e_1959320_1110x0_resize_q95_box.jpg\" alt=\"\" width=\"4002\" height=\"2998\"\u003e\n\u003c/picture\u003e\n \n \n \n\n","permalink":"https://ayats.org/blog/flake-blog/","tags":["Nix"],"title":"Static blog with Hugo and Nix flakes"},{"categories":["Linux"],"contents":"In this post I want to show a very brief introduction to Nix, the language and package manager, and how it can help you to achieve a fully reproducible development environment.\nWhat can Nix do for me? One of the features of Nix is that it is designed to allow for fully reproducible software development. Let\u0026rsquo;s say you have a project, for which you want your coworkers, for yourself in the future or anybody else to be able to get the same results as you. There will be many variables that will be taken into account, such as the programs available in the host, the versions, configurations, etc; that will affect your results (for example, a built binary or a developing environment). Nix allows you not only to specify which package versions your project depends, but also the specific build which will be used. So, given the exact same inputs, Nix will produce identical results, be it in your machine, your coworkers or in a remote server.\nSo what is Nix exactly? Nix is a purely functional programming language, dynamically typed, with a syntax very similar to JSON. Currently, the main purpose of this language is not being general purpose, but rather being the main tool of the Nix package manager.\nwith { a = 1; b = 2; }; { x = a + b }; # { x = 3; } Nix is in a strange situation, where many tutorials will try to teach you the basics semantics of the language, using arithmetics operations, handling strings, etc; but the real usage of the language is to build packages, in which these snippets might not be very useful.\npkgs.stdenv.mkDerivation { name = \u0026#34;viperML-home\u0026#34;; src = ./.; buildPhase = \u0026#39;\u0026#39; mkdir -p themes ln -s ${inputs.bookworm}themes/bookworm ${pkgs.hugo}/bin/hugo --minify \u0026#39;\u0026#39;; installPhase = \u0026#39;\u0026#39; cp -r public $out \u0026#39;\u0026#39;; meta = with pkgs.lib; { description = \u0026#34;My awesome webpage\u0026#34;; license = licenses.cc-by-nc-sa-40; platforms = platforms.all; }; This snippet of nix code may be more representative of how the Nix language can be used. It defines a derivation, which is how to build a package. While you could say that this package is called viperML-home (see name = ), the derivation name will be named differently if anything changes.\n mkDerivation is a function that creates the derivation, and takes as an argument an set of attributes, such as { foo = \u0026quot;bar\u0026quot;; foo2 = [ 1 2 ] }. name, meta define basic information about the package. buildPhase, installPhase are bash snippets, and correspond to how Nix will build the derivation. The derivation will just be a directory in /nix, with path $out, so we can just point our installers to put the files in there, and our derivation will be built.  Now the nix cli utilty, will be used to call this function, and install the files into /nix/store/\u0026lt;hash\u0026gt;-\u0026lt;package\u0026gt;-\u0026lt;version\u0026gt;. Because two packages with the same version and name can have different build or installation methods, a hash is computed and put into the name. This way, any number of \u0026ldquo;editions\u0026rdquo; of this package can coexist in the same system. Using one or another will be just a task of using the correct path.\nNow, every dependency of our package will be substituted by their exact derivation path. In the example snippet before, ${pkgs.hugo}/bin/hugo will be substituted by /nix/store/7jnn3g8871yqih4m61ggbjs1dif6hksa-hugo-0.91.2/bin/hugo and this will be the same across any system that calls the expression. If the derivation for hugo changes, their hashes will be different, so my viperML-home will be built different, and produce a different hash in the store. So, going backwards, if we use the same inputs for our build process, Nix will make sure to produce the same exact result; and if we know a derivation, we know how it was built exactly.\n But how do we make sure that Nix gets always the same inputs to build the same results?\n When calling that previous Nix expression, it was in a context with the pkgs variable defined. We can define this by referencing the commit of nixpkgs, the git repo from which we pull or packages. This can also be done with the upcoming feature, flakes, will will be discussed in a future post.\nHow do I start using Nix? Nix can be used in Linux, macOS or Windows via WSL2. Link to official documentation.\nAfter installing (and rebooting) your computer, you can start using Nix with:\nnix-shell --packages python3 This pull the python package, according to the nixpkgs revision configured in your channels, and put it into your path\npython --version # Python 3.9.9 which python # /nix/store/rppr9s436950i1dlzknbmz40m2xqqnxc-python3-3.9.9/bin/python Further reading Please, also consult this posts, to learn more about Nix:\n Alexander Bantyev - What is Nix? (written) Burke Libbey - Nix: What Even is it Though (video) Harikrishnan R - \u0026lsquo;Why you should never ever use NixOS\u0026rsquo;: a rebuttal (written)  ","date":"05 Jan, 2022","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003cpicture\u003e\n  \u003csource srcset=\"/images/post/liam-shaw-qEGtoChlnqk-unsplash_hu438eaa4e7c890ff4833f213d488c3e43_234413_545x0_resize_q95_h2_box.webp\" media=\"(max-width: 575px)\"\u003e\n  \u003csource srcset=\"/images/post/liam-shaw-qEGtoChlnqk-unsplash_hu438eaa4e7c890ff4833f213d488c3e43_234413_600x0_resize_q95_h2_box.webp\" media=\"(max-width: 767px)\"\u003e\n  \u003csource srcset=\"/images/post/liam-shaw-qEGtoChlnqk-unsplash_hu438eaa4e7c890ff4833f213d488c3e43_234413_700x0_resize_q95_h2_box.webp\" media=\"(max-width: 991px)\"\u003e\n  \u003csource srcset=\"/images/post/liam-shaw-qEGtoChlnqk-unsplash_hu438eaa4e7c890ff4833f213d488c3e43_234413_1110x0_resize_q95_h2_box.webp\"\u003e\n  \u003cimg loading=\"lazy\" decoding=\"async\" class=\"w-100 img-fluid rounded\" src=\"/images/post/liam-shaw-qEGtoChlnqk-unsplash_hu438eaa4e7c890ff4833f213d488c3e43_234413_1110x0_resize_q95_box.jpg\" alt=\"\" width=\"1920\" height=\"1280\"\u003e\n\u003c/picture\u003e\n \n \n \n\n","permalink":"https://ayats.org/blog/nix-intro/","tags":["Nix"],"title":"Into the Nix"}]