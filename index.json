[{"categories":["Linux"],"contents":"By using this blog as an example, I want to show you how you can use nix flakes for your project.\nWhy a flakes? Nix expressions can be pure, in the sense that the same inputs will give the same outputs. What flakes can solve is properly defining these inputs, sandboxing your build environments, as well as providing a unified interface for flake-based projects. If you don\u0026rsquo;t know what Nix is, I wrote a post here.\nHugo Hugo is a static site generator written in Go. From a users\u0026rsquo;s perspective, you can simply select a template and a written text with no formatting, and it will generate all the files required for the website, including all the HTML, CSS styles, JS scripts. The written input is in form of Markdown (my-post.md) files, which use simple syntax to format the text, and can be edited with any text editor (you can check the source for this post here).\n# This is a title in Markdown! Lorem ipsum dolor sit amet, consectetur adipiscing elit. Mauris non consectetur massa, quis egestas est. - This - is - a list ```bash echo -e \u0026#34;And this is a codes snippet\\n\u0026#34; ``` Hugo templates usually consist of one repository, which must be cloned into a subdirectory into your project, and then selected in your Hugo config file (config.toml). Some templates may also require you to copy a basic site example, to get a basis to start with. The template used for this blog at the time of the writing was Bookworm Light, and I found it through this gallery: Jamstack Themes.\nOnce your project is ready, building the site is as simple as:\nhugo # Or to get a live reloading preview in your browser: hugo server This will generate all the files required for the website, rendering out the details for the non-web developer like me.\nNix Enter the Nix questions. Which version of hugo was used to build the site? What any other dependencies, like the theme, how much do we need from the user environment? Can we fully recreate the static website from another computer? If properly configured, Nix can solve these problems, with the help of flakes.\nOn a high level, a flake.nix file will provide an interface for our:\n Inputs: our source files, the template and the package dependencies (hugo) Output: the static files generated  The basic boilerplate for a flake can be as follows:\n# flake.nix at project root { inputs = { nixpkgs.url = github:NixOS/nixpkgs/nixos-unstable; flake-utils-plus.url = github:gytis-ivaskevicius/flake-utils-plus; }; outputs = inputs@{ self, nixpkgs, flake-utils-plus, ... }: flake-utils-plus.lib.mkFlake { inherit self inputs; # Our system-independent outputs go here # E.g. NixOS configurations outputsBuilder = (channels: { # Our system-dependent outputs go here # E.g. packages, shell environments, etc }); }; } The flake syntax require you to put an attribute set { inputs = { ... }, outputs = { ... } }, such that:\n inputs will contain url\u0026rsquo;s other flakes or non-flake resources (such as any git repo). On the first call to the flake, these inputs will be \u0026ldquo;locked\u0026rdquo;: nix will pull the latest or specified version and write them to a flake.lock (similar to lock files in node, cargo, go, etc). inputs.flake-utils-plus is a library that provides some common functions used in flakes, that help us save some lines of code (GitHub link). output is a function, that that can take as input the inputs attribute. As a result, it returns another attribute set that contains our outputs. These outputs can take many forms, but we discuss our output in the next section.  We can set our blog output as follows:\n{ inputs = { nixpkgs.url = github:NixOS/nixpkgs/nixos-unstable; flake-utils-plus.url = github:gytis-ivaskevicius/flake-utils-plus; # Website template bookworm = { url = github:gethugothemes/bookworm-light; flake = false; }; }; outputs = inputs@{ self, nixpkgs, flake-utils-plus, ... }: flake-utils-plus.lib.mkFlake { inherit self inputs; outputsBuilder = (channels: let pkgs = channels.nixpkgs; # quicker alias in { blog = pkgs.stdenv.mkDerivation { name = \u0026#34;blog\u0026#34;; # our package name, irrelevant in this case src = ./.; buildPhase = \u0026#39;\u0026#39; mkdir -p themes ln -s ${inputs.bookworm}themes/bookworm ${pkgs.hugo}/bin/hugo --minify \u0026#39;\u0026#39;; installPhase = \u0026#39;\u0026#39; cp -r public $out \u0026#39;\u0026#39;; meta = with pkgs.lib; { description = \u0026#34;My awesome webpage\u0026#34;; license = licenses.cc-by-nc-sa-40; platforms = platforms.all; }; }; }); }; } We build our blog output with the function mkDerivation. You can think of a derivation, as a folder which holds any stuff, and built with Nix. So, the blog derivation will be a folder sitting in /nix/store/\u0026lt;hash\u0026gt;-blog, and it will contain all the contents of our static website. mkDerivation accepts some basic metadata, such as name, src or meta. The xxxPhase are just bash snippets, which run in a sandboxed environment (no packages, no internet, etc) to build our package. The build process is specific to this package, but the main idea still holds: we want to put our built website into $out (which is the path to the derivation, substituted by Nix). To do so, we call our hugo binary. Its location is in /nix/store/\u0026lt;hash\u0026gt;-hugo-\u0026lt;version\u0026gt;/bin/hugo, and this path can be called just by using ${pkgs.hugo}/bin/hugo. In the same fashion, our template called bookworm is also a derivation (a folder!) sitting in the nix store, that we can reference with ${inputs.bookworm}.\nOnce our flake is defined, nix build \u0026lt;the path to the project\u0026gt;#blog.x86_64-linux will read the flake.nix, read the flake.lock with the specific versions for our inputs, and begin the build process for our output (...#blog). Finally, a symlink to the derivation will be put under ./result for our convenience.\nIf you want to try for yourself, you can checkout this blog\u0026rsquo;s repository and go to my last commit before writing this post. If all the sources are still available, you will get a exact copy of the website at that time:\ngit clone https://github.com/viperML/home cd home git checkout 416172a7da5129347fa95c166120a34252cc7815 nix build .#home.x86_64-linux ls ./result # index.html, ... # or to get a live-reloading local server nix run .#serve GitHub pages To deploy the website, there are many solutions, but the quickest one was to use GitHub pages for our GitHub repo. In a nutshell:\n Push the static website to a specific branch Github will host deploy it for you You can even bring your own domain name, instead of the default XXX.github.io  You can check out the GitHub Pages quickstart guide for generic guide, but to use our nix infrastructure, we can use GitHub Actions, to automatically build and push our site in the cloud. To do so, we will hook up an action to build our project with Nix, and push it into the gh-pages branch. This action is a file located at \u0026lt;project root\u0026gt;/.github/workflows/\u0026lt;my-action\u0026gt;.yaml:\nname: Deploy to GH pages on: push: branches: # We only want to build the branch with the source - bookworm jobs: deploy: name: Deploy job runs-on: ubuntu-latest steps: - name: Checkout uses: actions/checkout@v2 with: fetch-depth: 0 # Nix Flakes doesn\u0026#39;t work on shallow clones - name: Install nix with flakes uses: cachix/install-nix-action@v16 with: install_url: https://github.com/numtide/nix-unstable-installer/releases/download/nix-2.6.0pre20211228_ed3bc63/install extra_nix_config: | experimental-features = nix-command flakes - name: Build static site run: nix build .#home.x86_64-linux - name: Deploy to gh-pages branch uses: peaceiris/actions-gh-pages@v3 if: github.ref == \u0026#39;refs/heads/bookworm\u0026#39; with: github_token: ${{ secrets.GITHUB_TOKEN }} # Nix build puts the result derivation under ./result publish_dir: ./result Finale I hope this post has been useful to demistify Nix and flakes, and to give you ideas on how to integrate it in your project. This project doesn\u0026rsquo;t have much complexity, and using flakes is probably overkill, but it may serve you as a reference on how to get started.\nFurther reading  Yannik Sander - Building with Nix Flakes for, eh .. reasons! Eelco Dolstra - Nix Flakes: An introduction and tutorial Alexander Bantyev - Practical Nix Flakes  ","date":"06 Jan, 2022","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003cpicture\u003e\n  \u003csource srcset=\"/images/post/daniele-buso-qzUenL35ZYw-unsplash_hueee4619a26c2b0ecdcb5ccab13f7095e_1959320_545x0_resize_q95_h2_box.webp\" media=\"(max-width: 575px)\"\u003e\n  \u003csource srcset=\"/images/post/daniele-buso-qzUenL35ZYw-unsplash_hueee4619a26c2b0ecdcb5ccab13f7095e_1959320_600x0_resize_q95_h2_box.webp\" media=\"(max-width: 767px)\"\u003e\n  \u003csource srcset=\"/images/post/daniele-buso-qzUenL35ZYw-unsplash_hueee4619a26c2b0ecdcb5ccab13f7095e_1959320_700x0_resize_q95_h2_box.webp\" media=\"(max-width: 991px)\"\u003e\n  \u003csource srcset=\"/images/post/daniele-buso-qzUenL35ZYw-unsplash_hueee4619a26c2b0ecdcb5ccab13f7095e_1959320_1110x0_resize_q95_h2_box.webp\"\u003e\n  \u003cimg loading=\"lazy\" decoding=\"async\" class=\"w-100 img-fluid rounded\" src=\"/images/post/daniele-buso-qzUenL35ZYw-unsplash_hueee4619a26c2b0ecdcb5ccab13f7095e_1959320_1110x0_resize_q95_box.jpg\" alt=\"\" width=\"4002\" height=\"2998\"\u003e\n\u003c/picture\u003e\n \n \n \n\n","permalink":"https://ayats.org/blog/flake-blog/","tags":["Nix","Hugo","GitHub"],"title":"Static blog with Hugo and Nix flakes"},{"categories":["Linux"],"contents":"In this post I want to show a very brief introduction to Nix, the language and package manager, and how it can help you to achieve a fully reproducible development environment.\nWhat can Nix do for me? One of the features of Nix is that it is designed to allow for fully reproducible software development. Let\u0026rsquo;s say you have a project, for which you want your coworkers, for yourself in the future or anybody else to be able to get the same results as you. There will be many variables that will be taken into account, such as the programs available in the host, the versions, configurations, etc; that will affect your results (for example, a built binary or a developing environment). Nix allows you not only to specify which package versions your project depends, but also the specific build which will be used. So, given the exact same inputs, Nix will produce identical results, be it in your machine, your coworkers or in a remote server.\nSo what is Nix exactly? Nix is a purely functional programming language, dynamically typed, with a syntax very similar to JSON. Currently, the main purpose of this language is not being general purpose, but rather being the main tool of the Nix package manager.\nwith { a = 1; b = 2; }; { x = a + b }; # { x = 3; } Nix is in a strange situation, where many tutorials will try to teach you the basics semantics of the language, using arithmetics operations, handling strings, etc; but the real usage of the language is to build packages, in which these snippets might not be very useful.\npkgs.stdenv.mkDerivation { name = \u0026#34;viperML-home\u0026#34;; src = ./.; buildPhase = \u0026#39;\u0026#39; mkdir -p themes ln -s ${inputs.bookworm}themes/bookworm ${pkgs.hugo}/bin/hugo --minify \u0026#39;\u0026#39;; installPhase = \u0026#39;\u0026#39; cp -r public $out \u0026#39;\u0026#39;; meta = with pkgs.lib; { description = \u0026#34;My awesome webpage\u0026#34;; license = licenses.cc-by-nc-sa-40; platforms = platforms.all; }; This snippet of nix code may be more representative of how the Nix language can be used. It defines a derivation, which is how to build a package. While you could say that this package is called viperML-home (see name = ), the derivation name will be named differently if anything changes.\n mkDerivation is a function that creates the derivation, and takes as an argument an set of attributes, such as { foo = \u0026quot;bar\u0026quot;; foo2 = [ 1 2 ] }. name, meta define basic information about the package. buildPhase, installPhase are bash snippets, and correspond to how Nix will build the derivation. The derivation will just be a directory in /nix, with path $out, so we can just point our installers to put the files in there, and our derivation will be built.  Now the nix cli utilty, will be used to call this function, and install the files into /nix/store/\u0026lt;hash\u0026gt;-\u0026lt;package\u0026gt;-\u0026lt;version\u0026gt;. Because two packages with the same version and name can have different build or installation methods, a hash is computed and put into the name. This way, any number of \u0026ldquo;editions\u0026rdquo; of this package can coexist in the same system. Using one or another will be just a task of using the correct path.\nNow, every dependency of our package will be substituted by their exact derivation path. In the example snippet before, ${pkgs.hugo}/bin/hugo will be substituted by /nix/store/7jnn3g8871yqih4m61ggbjs1dif6hksa-hugo-0.91.2/bin/hugo and this will be the same across any system that calls the expression. If the derivation for hugo changes, their hashes will be different, so my viperML-home will be built different, and produce a different hash in the store. So, going backwards, if we use the same inputs for our build process, Nix will make sure to produce the same exact result; and if we know a derivation, we know how it was built exactly.\n But how do we make sure that Nix gets always the same inputs to build the same results?\n When calling that previous Nix expression, it was in a context with the pkgs variable defined. We can define this by referencing the commit of nixpkgs, the git repo from which we pull or packages. This can also be done with the upcoming feature, flakes, will will be discussed in a future post.\nHow do I start using Nix? Nix can be used in Linux, macOS or Windows via WSL2. Link to official documentation.\nAfter installing (and rebooting) your computer, you can start using Nix with:\nnix-shell --packages python3 This pull the python package, according to the nixpkgs revision configured in your channels, and put it into your path\npython --version # Python 3.9.9 which python # /nix/store/rppr9s436950i1dlzknbmz40m2xqqnxc-python3-3.9.9/bin/python Further reading Please, also consult this posts, to learn more about Nix:\n Alexander Bantyev - What is Nix? (written) Burke Libbey - Nix: What Even is it Though (video) Harikrishnan R - \u0026lsquo;Why you should never ever use NixOS\u0026rsquo;: a rebuttal (written)  ","date":"05 Jan, 2022","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003cpicture\u003e\n  \u003csource srcset=\"/images/post/liam-shaw-qEGtoChlnqk-unsplash_hu438eaa4e7c890ff4833f213d488c3e43_234413_545x0_resize_q95_h2_box.webp\" media=\"(max-width: 575px)\"\u003e\n  \u003csource srcset=\"/images/post/liam-shaw-qEGtoChlnqk-unsplash_hu438eaa4e7c890ff4833f213d488c3e43_234413_600x0_resize_q95_h2_box.webp\" media=\"(max-width: 767px)\"\u003e\n  \u003csource srcset=\"/images/post/liam-shaw-qEGtoChlnqk-unsplash_hu438eaa4e7c890ff4833f213d488c3e43_234413_700x0_resize_q95_h2_box.webp\" media=\"(max-width: 991px)\"\u003e\n  \u003csource srcset=\"/images/post/liam-shaw-qEGtoChlnqk-unsplash_hu438eaa4e7c890ff4833f213d488c3e43_234413_1110x0_resize_q95_h2_box.webp\"\u003e\n  \u003cimg loading=\"lazy\" decoding=\"async\" class=\"w-100 img-fluid rounded\" src=\"/images/post/liam-shaw-qEGtoChlnqk-unsplash_hu438eaa4e7c890ff4833f213d488c3e43_234413_1110x0_resize_q95_box.jpg\" alt=\"\" width=\"1920\" height=\"1280\"\u003e\n\u003c/picture\u003e\n \n \n \n\n","permalink":"https://ayats.org/blog/nix-intro/","tags":["Nix"],"title":"Into the Nix"}]