[{"categories":["Linux"],"contents":"deploy-rs is a tool developed by Serokell to deploy NixOS machines into a remote server. It allows for \u0026ldquo;stateless\u0026rdquo; deployments, such that the machine that applies the configuration doesn\u0026rsquo;t know the state of the recipient machine. I found that the upstream example was a bit lacking, so I decided to write a guide on how I did use it to deploy a server to Hetzner Cloud.\nThis guide also assumes that you are doing from in a NixOS machine, but it may be possible to do from a generic linux distro with just the nix package manager.\nBase flake You can follow along with the repository I created for this demo: github:viperML/deploy-rs-example.\nA high level overview of the flake will be:\n Inputs:  Nixos-21.11, the latest version of NixOS at the time of writing (please update if you see fit). deploy-rs flake-utils-plus, to help with some flake-related tasks.   Outputs:  A NixOS configuration for the hostname hetzner A development shell that we can use to use the deploy binary, with $ nix develop    flake.nix\n{ description = \u0026#34;My server flake\u0026#34;; inputs = { nixpkgs.url = github:NixOS/nixpkgs/nixos-21.11; flake-utils-plus.url = github:gytis-ivaskevicius/flake-utils-plus; deploy-rs = { url = github:serokell/deploy-rs; inputs.nixpkgs.follows = \u0026#34;nixpkgs\u0026#34;; }; }; outputs = inputs@{ self, nixpkgs, flake-utils-plus, ... }: let nixosModules = flake-utils-plus.lib.exportModules ( nixpkgs.lib.mapAttrsToList (name: value: ./nixosModules/${name}) (builtins.readDir ./nixosModules) ); in flake-utils-plus.lib.mkFlake { inherit self inputs nixosModules; hosts = { hetzner.modules = with nixosModules; [ common admin hardware-hetzner ]; }; outputsBuilder = (channels: { devShell = channels.nixpkgs.mkShell { name = \u0026#34;my-deploy-shell\u0026#34;; buildInputs = with channels.nixpkgs; [ nixUnstable inputs.deploy-rs.defaultPackage.${system} ]; }; }); checks = builtins.mapAttrs (system: deployLib: deployLib.deployChecks self.deploy) inputs.deploy-rs.lib; }; } Let\u0026rsquo;s disect our outputs:\n nixosModules: we are importing NixOS modules from files, such as ./nixosModules/\u0026lt;my_module.nix\u0026gt;, and placing them into our variable nixosModules.\u0026lt;my_module\u0026gt;. hosts.hetzner.modules is a construct provided by flake-utils-plus that directly defines NixOS systems, by specifying the modules. devShell creates a development shell that we can call with nix develop, that contains our deploy binary. We place it in a flake-utils-plus\u0026rsquo;s outputsBuilder, because it will define a devShell per system (x86_64-linux, aarch64-linux, etc).  Then, to define our system configuration, all we have to do is drop them into ./nixosModules/\u0026lt;my_module.nix\u0026gt;, and reference them into hosts.hetzner.modules. I believe that this helps to maintain clarity with a module per task, but feel free to go for a different approach.\n  ./nixosModules/common.nix: this module defines some basic NixOS configurations, such as enabling flake support and setting our system version.\n  ./nixosModules/hardware-hetzner.nix: this module defines specific settings for our Hetzner server, such as the filesystems and network configuration. The setups assumes that it will be installed to:\n A disk /dev/sda with GPT labels Boot partition /dev/sda1 for BIOS booting with GRUB BTRFS partition /dev/disk-by-label/NIXOS, which includes some subvolumes for different components.    ./nixosModules/admin.nix: the module defines the user admin, with inital password 1234 and passwordless sudo (wheel group). Its is very important to set you SSH public key for the user, as deploy-rs requires you to be able to log-in into the server without a password.\n# ... users.users.admin = { # ... openssh.authorizedKeys.keys = [ \u0026#34;your SSH public key here goes here\u0026#34; ]; }; # ...   First install We need to set-up a base system that we can deploy on. The high-level overview is:\n Boot up the live NixOS image Wipe and reformat the VM disk Install our system  To perform the installation, we can choose any OS image, as it won\u0026rsquo;t be used.\nAfter creating the machine, mount the NixOS install disk, reboot the machine and access the console (with the button next to power).\nOur server disk will be available in /dev/sda. To automate the process, I created a simple script to automate the installation, that will partition our disk, format it, and install NixOS. If you modified hardware-hetzner.nix for a different partitioning, just perform the steps manually.\nsudo -s nix-shell -p git git clone https://github.com/viperML/deploy-rs-example cd deploy-rs-example ./install.sh Finally, shutdown the server, remove the NixOS disk and boot it. Ssh into the server to add it yo your known hosts.\nssh admin@\u0026lt;you server IP address\u0026gt; Creating a test module We are ready to deploy a custom configuration into the server. For this example, we will just enable docker. We will create a new file to organize the docker related-options as such:\n./nixosModules/docker.nix\n{ config, pkgs, ... }: { services.nginx.enable = true; users.users.admin.extraGroups = [ \u0026#34;docker\u0026#34; ]; } And add docker it into our flake\u0026rsquo;s outputs.hosts.hetzner.modules.\nYou can build a VM with the configuration, to check that it is working properly:\nnix build .#nixosConfigurations.hetzner.config.system.build.vm ./result/bin/run-hetzner-vm  Deploying the new configuration Finally, all we have to do is configure deploy-rs. To do so, we have to define \u0026ldquo;nodes\u0026rdquo;, which in turn can have different \u0026ldquo;profiles\u0026rdquo;, and a profile uses a NixOS configuration.\nIn this example, our node my-node will will use the profile my-profile which uses the hetzner NixOS config:\n#... outputs = { # ... deploy.nodes = { my-node = { hostname = \u0026#34;\u0026lt;your address goes here\u0026gt;\u0026#34;; fastConnection = false; profiles = { my-profile = { sshUser = \u0026#34;admin\u0026#34;; path = inputs.deploy-rs.lib.x86_64-linux.activate.nixos self.nixosConfigurations.hetzner; user = \u0026#34;root\u0026#34;; }; }; }; }; # ... } to deploy our node, we enter the devShell that we defined earlier in out flake, to have access to the deploy binary:\nnix develop deploy .#my-node.my-profile  Finale I hope that this proccess servers you as an example of how to use deploy-rs and NixOS for your project. Some final ideas to go from here:\n Fully automate the deployment process, by evaluating the flake when pushing a new commit, etc Add different roles for different nodes Use sops-nix to deploy your application secrets Change the partitioning scheme (maybe a simpler EXT4, or ZFS subvolumes \u0026hellip;)  If you encounter any problem with the template, feel free to open an issue at the repo github:viperML/deploy-rs-example.\n","date":"12 Jan, 2022","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003cpicture\u003e\n  \u003csource srcset=\"/images/post/christopher-burns-Wiu3w-99tNg-unsplash_hu3cf669ed3b0b7cae22419bd27b7e4fa9_2422235_545x0_resize_q95_h2_box.webp\" media=\"(max-width: 575px)\"\u003e\n  \u003csource srcset=\"/images/post/christopher-burns-Wiu3w-99tNg-unsplash_hu3cf669ed3b0b7cae22419bd27b7e4fa9_2422235_600x0_resize_q95_h2_box.webp\" media=\"(max-width: 767px)\"\u003e\n  \u003csource srcset=\"/images/post/christopher-burns-Wiu3w-99tNg-unsplash_hu3cf669ed3b0b7cae22419bd27b7e4fa9_2422235_700x0_resize_q95_h2_box.webp\" media=\"(max-width: 991px)\"\u003e\n  \u003csource srcset=\"/images/post/christopher-burns-Wiu3w-99tNg-unsplash_hu3cf669ed3b0b7cae22419bd27b7e4fa9_2422235_1110x0_resize_q95_h2_box.webp\"\u003e\n  \u003cimg loading=\"lazy\" decoding=\"async\" class=\"w-100 img-fluid rounded\" src=\"/images/post/christopher-burns-Wiu3w-99tNg-unsplash_hu3cf669ed3b0b7cae22419bd27b7e4fa9_2422235_1110x0_resize_q95_box.jpg\" alt=\"\" width=\"5760\" height=\"3840\"\u003e\n\u003c/picture\u003e\n \n \n \n\n","permalink":"https://ayats.org/blog/deploy-rs-example/","tags":["Nix","Cloud"],"title":"NixOS on Hetzner Cloud with deploy-rs"},{"categories":["Linux"],"contents":"By using this blog as an example, I want to show you how you can use nix flakes for your project.\nWhy flakes? Nix expressions can be pure, in the sense that the same inputs will give the same outputs. What flakes can solve is properly defining these inputs, sandboxing your build environments, as well as providing a unified interface for flake-based projects. If you don\u0026rsquo;t know what Nix is, I wrote a post here.\nHugo Hugo is a static site generator written in Go. From a users\u0026rsquo;s perspective, you can simply select a template and a written text with no formatting, and it will generate all the files required for the website, including all the HTML, CSS styles, JS scripts. The written input is in form of Markdown (my-post.md) files, which use simple syntax to format the text, and can be edited with any text editor (you can check the source for this post here).\n# This is a title in Markdown! Lorem ipsum dolor sit amet, consectetur adipiscing elit. Mauris non consectetur massa, quis egestas est. - This - is - a list ```bash echo -e \u0026#34;And this is a codes snippet\\n\u0026#34; ``` Hugo templates usually consist of one repository, which must be cloned into a subdirectory into your project, and then selected in your Hugo config file (config.toml). Some templates may also require you to copy a basic site example, to get a basis to start with. The template used for this blog at the time of the writing was Bookworm Light, and I found it through this gallery: Jamstack Themes.\nOnce your project is ready, building the site is as simple as:\nhugo # Or to get a live reloading preview in your browser: hugo server This will generate all the files required for the website, rendering out the details for the non-web developer like me.\nNix Enter the Nix questions. Which version of hugo was used to build the site? What any other dependencies, like the theme, how much do we need from the user environment? Can we fully recreate the static website from another computer? If properly configured, Nix can solve these problems, with the help of flakes.\nOn a high level, a flake.nix file will provide an interface for our:\n Inputs: our source files, the template and the package dependencies (hugo) Output: the static files generated  The basic boilerplate for a flake can be as follows:\n# flake.nix at project root { inputs = { nixpkgs.url = github:NixOS/nixpkgs/nixos-unstable; flake-utils-plus.url = github:gytis-ivaskevicius/flake-utils-plus; }; outputs = inputs@{ self, nixpkgs, flake-utils-plus, ... }: flake-utils-plus.lib.mkFlake { inherit self inputs; # Our system-independent outputs go here # E.g. NixOS configurations outputsBuilder = (channels: { # Our system-dependent outputs go here # E.g. packages, shell environments, etc }); }; } The flake syntax require you to put an attribute set { inputs = { ... }, outputs = { ... } }, such that:\n inputs will contain url\u0026rsquo;s other flakes or non-flake resources (such as any git repo). On the first call to the flake, these inputs will be \u0026ldquo;locked\u0026rdquo;: nix will pull the latest or specified version and write them to a flake.lock (similar to lock files in node, cargo, go, etc). inputs.flake-utils-plus is a library that provides some common functions used in flakes, that help us save some lines of code (GitHub link). output is a function, that that can take as input the inputs attribute. As a result, it returns another attribute set that contains our outputs. These outputs can take many forms, but we discuss our output in the next section.  We can set our blog\u0026rsquo;s flake outputs as follows:\n{ inputs = { nixpkgs.url = github:NixOS/nixpkgs/nixos-unstable; flake-utils-plus.url = github:gytis-ivaskevicius/flake-utils-plus; # Website template bookworm = { url = github:gethugothemes/bookworm-light; flake = false; }; }; outputs = inputs@{ self, nixpkgs, flake-utils-plus, ... }: flake-utils-plus.lib.mkFlake { inherit self inputs; outputsBuilder = (channels: let pkgs = channels.nixpkgs; # quicker alias in { home = pkgs.stdenv.mkDerivation { name = \u0026#34;home\u0026#34;; # our package name, irrelevant in this case src = ./.; buildPhase = \u0026#39;\u0026#39; mkdir -p themes ln -s ${inputs.bookworm}themes/bookworm ${pkgs.hugo}/bin/hugo --minify \u0026#39;\u0026#39;; installPhase = \u0026#39;\u0026#39; cp -r public $out \u0026#39;\u0026#39;; meta = with pkgs.lib; { description = \u0026#34;My awesome webpage\u0026#34;; license = licenses.cc-by-nc-sa-40; platforms = platforms.all; }; }; }); }; } We build our home output with the function mkDerivation. You can think of a derivation, as a folder which holds any stuff, and built with Nix. So, the home derivation will be a folder sitting in /nix/store/\u0026lt;hash\u0026gt;-home, and it will contain all the contents of our static website. mkDerivation accepts some basic metadata, such as name, src or meta. The xxxPhase are just bash snippets, which run in a sandboxed environment (no packages, no internet, etc) to build our package. The build process is specific to this package, but the main idea still holds: we want to put our built website into $out (which is the path to the derivation, substituted by Nix). To do so, we call our hugo binary. Its location is in /nix/store/\u0026lt;hash\u0026gt;-hugo-\u0026lt;version\u0026gt;/bin/hugo, and this path can be called just by using ${pkgs.hugo}/bin/hugo. In the same fashion, our template called bookworm is also a derivation (a folder!) sitting in the nix store, that we can reference with ${inputs.bookworm}.\nOnce our flake is defined, nix build \u0026lt;the path to the project\u0026gt;#home.x86_64-linux will read the flake.nix, read the flake.lock with the specific versions for our inputs, and begin the build process for our output (...#home). Finally, a symlink to the derivation will be put under ./result for our convenience.\nIf you want to try for yourself, you can checkout this blog\u0026rsquo;s repository and go to my last commit before writing this post. If all the sources are still available, you will get a exact copy of the website at that time:\ngit clone https://github.com/viperML/home cd home git checkout 416172a7da5129347fa95c166120a34252cc7815 nix build .#home.x86_64-linux ls ./result # index.html, ... # or to get a live-reloading local server nix run .#serve GitHub pages To deploy the website, there are many solutions, but the quickest one was to use GitHub pages for our GitHub repo. In a nutshell:\n Push the static website to a specific branch Github will host deploy it for you You can even bring your own domain name, instead of the default XXX.github.io  You can check out the GitHub Pages quickstart guide for generic guide, but to use our nix infrastructure, we can use GitHub Actions, to automatically build and push our site in the cloud. To do so, we will hook up an action to build our project with Nix, and push it into the gh-pages branch. This action is a file located at \u0026lt;project root\u0026gt;/.github/workflows/\u0026lt;my-action\u0026gt;.yaml:\nname: Deploy to GH pages on: push: branches: # We only want to build the branch with the source - bookworm jobs: deploy: name: Deploy job runs-on: ubuntu-latest steps: - name: Checkout uses: actions/checkout@v2 with: fetch-depth: 0 # Nix Flakes doesn\u0026#39;t work on shallow clones - name: Install nix with flakes uses: cachix/install-nix-action@v16 with: install_url: https://github.com/numtide/nix-unstable-installer/releases/download/nix-2.6.0pre20211228_ed3bc63/install extra_nix_config: | experimental-features = nix-command flakes - name: Build static site run: nix build .#home.x86_64-linux - name: Deploy to gh-pages branch uses: peaceiris/actions-gh-pages@v3 if: github.ref == \u0026#39;refs/heads/bookworm\u0026#39; with: github_token: ${{ secrets.GITHUB_TOKEN }} # Nix build puts the result derivation under ./result publish_dir: ./result Finale I hope this post has been useful to demistify Nix and flakes, and to give you ideas on how to integrate it in your project. This project doesn\u0026rsquo;t have much complexity, and using flakes is probably overkill, but it may serve you as a reference on how to get started.\nFurther reading  Yannik Sander - Building with Nix Flakes for, eh .. reasons! Eelco Dolstra - Nix Flakes: An introduction and tutorial Alexander Bantyev - Practical Nix Flakes  ","date":"06 Jan, 2022","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003cpicture\u003e\n  \u003csource srcset=\"/images/post/daniele-buso-qzUenL35ZYw-unsplash_hueee4619a26c2b0ecdcb5ccab13f7095e_1959320_545x0_resize_q95_h2_box.webp\" media=\"(max-width: 575px)\"\u003e\n  \u003csource srcset=\"/images/post/daniele-buso-qzUenL35ZYw-unsplash_hueee4619a26c2b0ecdcb5ccab13f7095e_1959320_600x0_resize_q95_h2_box.webp\" media=\"(max-width: 767px)\"\u003e\n  \u003csource srcset=\"/images/post/daniele-buso-qzUenL35ZYw-unsplash_hueee4619a26c2b0ecdcb5ccab13f7095e_1959320_700x0_resize_q95_h2_box.webp\" media=\"(max-width: 991px)\"\u003e\n  \u003csource srcset=\"/images/post/daniele-buso-qzUenL35ZYw-unsplash_hueee4619a26c2b0ecdcb5ccab13f7095e_1959320_1110x0_resize_q95_h2_box.webp\"\u003e\n  \u003cimg loading=\"lazy\" decoding=\"async\" class=\"w-100 img-fluid rounded\" src=\"/images/post/daniele-buso-qzUenL35ZYw-unsplash_hueee4619a26c2b0ecdcb5ccab13f7095e_1959320_1110x0_resize_q95_box.jpg\" alt=\"\" width=\"4002\" height=\"2998\"\u003e\n\u003c/picture\u003e\n \n \n \n\n","permalink":"https://ayats.org/blog/flake-blog/","tags":["Nix","Hugo","GitHub"],"title":"Static blog with Hugo and Nix flakes"},{"categories":["Linux"],"contents":"In this post I want to show a very brief introduction to Nix, the language and package manager, and how it can help you to achieve a fully reproducible development environment.\nWhat can Nix do for me? One of the features of Nix is that it is designed to allow for fully reproducible software development. Let\u0026rsquo;s say you have a project, for which you want your coworkers, for yourself in the future or anybody else to be able to get the same results as you. There will be many variables that will be taken into account, such as the programs available in the host, the versions, configurations, etc; that will affect your results (for example, a built binary or a developing environment). Nix allows you not only to specify which package versions your project depends, but also the specific build which will be used. So, given the exact same inputs, Nix will produce identical results, be it in your machine, your coworkers or in a remote server.\nSo what is Nix exactly? Nix is a purely functional programming language, dynamically typed, with a syntax very similar to JSON. Currently, the main purpose of this language is not being general purpose, but rather being the main tool of the Nix package manager.\nwith { a = 1; b = 2; }; { x = a + b }; # { x = 3; } Nix is in a strange situation, where many tutorials will try to teach you the basics semantics of the language, using arithmetics operations, handling strings, etc; but the real usage of the language is to build packages, in which these snippets might not be very useful.\npkgs.stdenv.mkDerivation { name = \u0026#34;viperML-home\u0026#34;; src = ./.; buildPhase = \u0026#39;\u0026#39; mkdir -p themes ln -s ${inputs.bookworm}themes/bookworm ${pkgs.hugo}/bin/hugo --minify \u0026#39;\u0026#39;; installPhase = \u0026#39;\u0026#39; cp -r public $out \u0026#39;\u0026#39;; meta = with pkgs.lib; { description = \u0026#34;My awesome webpage\u0026#34;; license = licenses.cc-by-nc-sa-40; platforms = platforms.all; }; This snippet of nix code may be more representative of how the Nix language can be used. It defines a derivation, which is how to build a package. While you could say that this package is called viperML-home (see name = ), the derivation name will be named differently if anything changes.\n mkDerivation is a function that creates the derivation, and takes as an argument an set of attributes, such as { foo = \u0026quot;bar\u0026quot;; foo2 = [ 1 2 ] }. name, meta define basic information about the package. buildPhase, installPhase are bash snippets, and correspond to how Nix will build the derivation. The derivation will just be a directory in /nix, with path $out, so we can just point our installers to put the files in there, and our derivation will be built.  Now the nix cli utilty, will be used to call this function, and install the files into /nix/store/\u0026lt;hash\u0026gt;-\u0026lt;package\u0026gt;-\u0026lt;version\u0026gt;. Because two packages with the same version and name can have different build or installation methods, a hash is computed and put into the name. This way, any number of \u0026ldquo;editions\u0026rdquo; of this package can coexist in the same system. Using one or another will be just a task of using the correct path.\nNow, every dependency of our package will be substituted by their exact derivation path. In the example snippet before, ${pkgs.hugo}/bin/hugo will be substituted by /nix/store/7jnn3g8871yqih4m61ggbjs1dif6hksa-hugo-0.91.2/bin/hugo and this will be the same across any system that calls the expression. If the derivation for hugo changes, their hashes will be different, so my viperML-home will be built different, and produce a different hash in the store. So, going backwards, if we use the same inputs for our build process, Nix will make sure to produce the same exact result; and if we know a derivation, we know how it was built exactly.\n But how do we make sure that Nix gets always the same inputs to build the same results?\n When calling that previous Nix expression, it was in a context with the pkgs variable defined. We can define this by referencing the commit of nixpkgs, the git repo from which we pull or packages. This can also be done with the upcoming feature, flakes, will will be discussed in a future post.\nHow do I start using Nix? Nix can be used in Linux, macOS or Windows via WSL2. Link to official documentation.\nAfter installing (and rebooting) your computer, you can start using Nix with:\nnix-shell --packages python3 This pull the python package, according to the nixpkgs revision configured in your channels, and put it into your path\npython --version # Python 3.9.9 which python # /nix/store/rppr9s436950i1dlzknbmz40m2xqqnxc-python3-3.9.9/bin/python Further reading Please, also consult this posts, to learn more about Nix:\n Alexander Bantyev - What is Nix? (written) Burke Libbey - Nix: What Even is it Though (video) Harikrishnan R - \u0026lsquo;Why you should never ever use NixOS\u0026rsquo;: a rebuttal (written)  ","date":"05 Jan, 2022","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003cpicture\u003e\n  \u003csource srcset=\"/images/post/liam-shaw-qEGtoChlnqk-unsplash_hu438eaa4e7c890ff4833f213d488c3e43_234413_545x0_resize_q95_h2_box.webp\" media=\"(max-width: 575px)\"\u003e\n  \u003csource srcset=\"/images/post/liam-shaw-qEGtoChlnqk-unsplash_hu438eaa4e7c890ff4833f213d488c3e43_234413_600x0_resize_q95_h2_box.webp\" media=\"(max-width: 767px)\"\u003e\n  \u003csource srcset=\"/images/post/liam-shaw-qEGtoChlnqk-unsplash_hu438eaa4e7c890ff4833f213d488c3e43_234413_700x0_resize_q95_h2_box.webp\" media=\"(max-width: 991px)\"\u003e\n  \u003csource srcset=\"/images/post/liam-shaw-qEGtoChlnqk-unsplash_hu438eaa4e7c890ff4833f213d488c3e43_234413_1110x0_resize_q95_h2_box.webp\"\u003e\n  \u003cimg loading=\"lazy\" decoding=\"async\" class=\"w-100 img-fluid rounded\" src=\"/images/post/liam-shaw-qEGtoChlnqk-unsplash_hu438eaa4e7c890ff4833f213d488c3e43_234413_1110x0_resize_q95_box.jpg\" alt=\"\" width=\"1920\" height=\"1280\"\u003e\n\u003c/picture\u003e\n \n \n \n\n","permalink":"https://ayats.org/blog/nix-intro/","tags":["Nix"],"title":"Into the Nix"}]